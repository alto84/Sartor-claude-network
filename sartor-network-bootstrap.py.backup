#!/usr/bin/env python3
"""
Sartor Network Bootstrap - Single File Agent Onboarding

USAGE FOR A FRESH LLM:
    Just run: python3 sartor-network-bootstrap.py

This single file contains everything needed to connect a new Claude agent
to the Sartor Claude Network. No other dependencies required (except requests).

WHAT IT DOES:
    1. Connects you to the Firebase-based MCP network
    2. Gives you access to all MCP tools
    3. Enables sub-agent auto-onboarding
    4. Provides examples and documentation
"""

import json
import re
import time
import uuid
import requests
from datetime import datetime
from typing import Dict, Any, Optional, List


def requires_connection(func):
    """Decorator to ensure operation requires active connection"""
    def wrapper(self, *args, **kwargs):
        if not self.is_connected:
            raise ConnectionError(
                f"Cannot execute {func.__name__}: client is not connected. "
                "Call connect() first."
            )
        return func(self, *args, **kwargs)
    return wrapper


class SartorNetworkClient:
    """
    Complete Firebase MCP client in a single class.

    This is all you need to connect to the Sartor Claude Network.
    """

    def __init__(
        self,
        firebase_url: str = "https://home-claude-network-default-rtdb.firebaseio.com/",
        agent_id: Optional[str] = None,
        agent_name: Optional[str] = None,
    ):
        """
        Initialize network client.

        Args:
            firebase_url: Firebase Realtime Database URL
            agent_id: Your agent ID (auto-generated if not provided)
            agent_name: Friendly name for your agent (optional)
        """
        self.firebase_url = firebase_url.rstrip("/")
        self.agent_id = agent_id or self._generate_agent_id()
        self.agent_name = agent_name or f"Agent-{self.agent_id[:12]}"
        self.is_connected = False

        print(f"ğŸ¤– Sartor Network Client initialized")
        print(f"   Agent ID: {self.agent_id}")
        print(f"   Agent Name: {self.agent_name}")

    def _validate_agent_id(self, agent_id: str, param_name: str = "agent_id") -> None:
        """Validate agent ID format"""
        if not agent_id:
            raise ValueError(f"{param_name} cannot be empty")

        # Allow: alphanumeric, hyphens, underscores, dots
        # Format: letters/numbers followed by optional hyphens/underscores/dots
        pattern = r'^[a-zA-Z0-9][a-zA-Z0-9._-]*$'

        if not re.match(pattern, agent_id):
            raise ValueError(
                f"Invalid {param_name} format: '{agent_id}'. "
                "Must contain only alphanumeric characters, hyphens, underscores, and dots. "
                "Cannot start with special characters."
            )

        # Additional length check
        if len(agent_id) > 128:
            raise ValueError(f"{param_name} too long (max 128 characters)")

    def _generate_agent_id(self) -> str:
        """Generate unique agent ID"""
        timestamp = int(time.time())
        random_id = str(uuid.uuid4())[:8]
        return f"claude-{timestamp}-{random_id}"

    def _firebase_request(
        self, method: str, path: str, data: Optional[Dict] = None
    ) -> Optional[Dict]:
        """Make HTTP request to Firebase REST API"""
        url = f"{self.firebase_url}/agents-network{path}.json"

        try:
            if method == "GET":
                response = requests.get(url, timeout=10)
            elif method == "PUT":
                response = requests.put(url, json=data, timeout=10)
            elif method == "POST":
                response = requests.post(url, json=data, timeout=10)
            elif method == "PATCH":
                response = requests.patch(url, json=data, timeout=10)
            elif method == "DELETE":
                response = requests.delete(url, timeout=10)
            else:
                raise ValueError(f"Unsupported method: {method}")

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            print(f"âš ï¸  Firebase request failed: {e}")
            return None

    def connect(self) -> bool:
        """
        Connect to the Sartor Claude Network.

        Returns:
            True if connection successful, False otherwise
        """
        print(f"\nğŸŒ Connecting to Sartor Claude Network...")

        # Register agent
        agent_data = {
            "agent_id": self.agent_id,
            "agent_name": self.agent_name,
            "status": "online",
            "capabilities": ["communication", "tasks", "skills", "knowledge"],
            "joined_at": datetime.now().isoformat(),
            "last_seen": datetime.now().isoformat(),
        }

        result = self._firebase_request("PUT", f"/agents/{self.agent_id}", agent_data)

        if result:
            # Set presence
            presence_data = {
                "online": True,
                "last_seen": datetime.now().isoformat()
            }
            self._firebase_request("PUT", f"/presence/{self.agent_id}", presence_data)

            self.is_connected = True
            print(f"âœ… Connected to Sartor Claude Network!")
            print(f"   Firebase: {self.firebase_url}")
            print(f"   Status: Online")

            # Show network status
            agents = self.agent_list()
            print(f"   Network: {len(agents)} agents online")

            return True
        else:
            print(f"âŒ Connection failed")
            return False

    def disconnect(self):
        """Disconnect from network"""
        if not self.is_connected:
            return

        self._firebase_request(
            "PATCH",
            f"/agents/{self.agent_id}",
            {"status": "offline", "last_seen": datetime.now().isoformat()}
        )

        self._firebase_request(
            "PATCH",
            f"/presence/{self.agent_id}",
            {"online": False, "last_seen": datetime.now().isoformat()}
        )

        self.is_connected = False
        print(f"ğŸ‘‹ Disconnected from network")

    # === Communication Tools ===

    @requires_connection
    def message_send(self, to_agent_id: str, content: str) -> bool:
        """Send direct message to another agent"""
        # BUG-003: Input type validation
        if content is None:
            raise ValueError("Message content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Message content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Message content cannot be empty or whitespace only")

        # BUG-006: Agent ID validation
        self._validate_agent_id(to_agent_id, "to_agent_id")

        # BUG-004: Recipient validation
        recipient = self._firebase_request("GET", f"/agents/{to_agent_id}")
        if recipient is None:
            raise ValueError(f"Agent '{to_agent_id}' does not exist or is not registered")

        message_id = str(uuid.uuid4())
        message_data = {
            "from": self.agent_id,
            "to": to_agent_id,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "read": False,
        }

        result = self._firebase_request(
            "PUT",
            f"/messages/direct/{to_agent_id}/{message_id}",
            message_data
        )

        if result:
            print(f"ğŸ“¤ Message sent to {to_agent_id}")
            return True
        return False

    @requires_connection
    def message_broadcast(self, content: str) -> bool:
        """Broadcast message to all agents"""
        # BUG-003: Input type validation
        if content is None:
            raise ValueError("Message content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Message content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Message content cannot be empty or whitespace only")

        message_id = str(uuid.uuid4())
        message_data = {
            "from": self.agent_id,
            "content": content,
            "timestamp": datetime.now().isoformat(),
        }

        result = self._firebase_request(
            "PUT",
            f"/messages/broadcast/{message_id}",
            message_data
        )

        if result:
            print(f"ğŸ“¢ Broadcast sent: {content}")
            return True
        return False

    def message_read(self, count: int = 10) -> List[Dict]:
        """Read messages for this agent"""
        messages = self._firebase_request("GET", f"/messages/direct/{self.agent_id}")

        if not messages:
            return []

        message_list = []
        for msg_id, msg_data in messages.items():
            if isinstance(msg_data, dict):
                msg_data["message_id"] = msg_id
                message_list.append(msg_data)

        message_list.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        return message_list[:count]

    # === Task Coordination Tools ===

    def task_list(self, status: str = "available") -> List[Dict]:
        """List tasks with given status"""
        tasks = self._firebase_request("GET", "/tasks")

        if not tasks:
            return []

        task_list = []
        for task_id, task_data in tasks.items():
            if isinstance(task_data, dict) and task_data.get("status") == status:
                task_data["task_id"] = task_id
                task_list.append(task_data)

        return task_list

    @requires_connection
    def task_claim(self, task_id: str, max_retries: int = 5) -> bool:
        """
        Claim an available task using optimistic locking.

        This method implements a race-condition-safe claim mechanism:
        1. Read task with current lock_version
        2. Write claim with incremented lock_version
        3. Verify we actually own the task after write
        4. Retry with exponential backoff if another agent claimed it

        Args:
            task_id: The task ID to claim
            max_retries: Maximum number of retry attempts (default: 5)

        Returns:
            True if successfully claimed, False otherwise
        """
        import random

        for attempt in range(max_retries):
            # Step 1: Read current task state
            task = self._firebase_request("GET", f"/tasks/{task_id}")

            if not task:
                if attempt == 0:
                    print(f"âŒ Task {task_id} not found")
                return False

            if task.get("status") != "available":
                # Task is already claimed, completed, or cancelled
                if attempt == 0:
                    print(f"âŒ Task {task_id} not available (status: {task.get('status')})")
                return False

            # Get current lock version (initialize to 0 if not present)
            current_version = task.get("lock_version", 0)

            # Step 2: Attempt to claim with optimistic lock
            claim_data = {
                "status": "claimed",
                "claimed_by": self.agent_id,
                "claimed_at": datetime.now().isoformat(),
                "lock_version": current_version + 1,  # Increment version
            }

            result = self._firebase_request("PATCH", f"/tasks/{task_id}", claim_data)

            if not result:
                print(f"âŒ Failed to write claim for task {task_id}")
                return False

            # Step 3: VERIFY we actually own the task (critical for race condition fix!)
            # Small delay to let Firebase propagate the write
            time.sleep(0.05)

            verification = self._firebase_request("GET", f"/tasks/{task_id}")

            if not verification:
                print(f"âŒ Failed to verify claim for task {task_id}")
                return False

            # Check if we are the owner
            if verification.get("claimed_by") == self.agent_id:
                print(f"âœ… Successfully claimed task: {task.get('title', task_id)}")
                return True

            # Another agent claimed it - retry with exponential backoff
            if attempt < max_retries - 1:
                backoff = (0.1 * (2 ** attempt)) + (random.random() * 0.1)
                print(f"âš ï¸  Task {task_id} claimed by another agent, retrying in {backoff:.2f}s (attempt {attempt + 1}/{max_retries})")
                time.sleep(backoff)

        print(f"âŒ Failed to claim task {task_id} after {max_retries} attempts")
        return False

    @requires_connection
    def task_create(self, title: str, description: str, task_data: Optional[Dict] = None) -> str:
        """Create a new task"""
        # BUG-007: Empty field validation
        if not title or not title.strip():
            raise ValueError("Task title cannot be empty")
        if not description or not description.strip():
            raise ValueError("Task description cannot be empty")

        # Trim whitespace
        title = title.strip()
        description = description.strip()

        # Optional: length limits
        if len(title) > 200:
            raise ValueError("Task title too long (max 200 characters)")
        if len(description) > 5000:
            raise ValueError("Task description too long (max 5000 characters)")

        task_id = str(uuid.uuid4())
        task = {
            "task_id": task_id,
            "title": title,
            "description": description,
            "status": "available",
            "created_by": self.agent_id,
            "created_at": datetime.now().isoformat(),
            "data": task_data or {},
            "lock_version": 0,  # Initialize lock version for optimistic locking (BUG-001 fix)
        }

        result = self._firebase_request("PUT", f"/tasks/{task_id}", task)

        if result:
            print(f"ğŸ“ Created task: {title}")
            return task_id
        return ""

    @requires_connection
    def task_update(self, task_id: str, status: str, result: Optional[Dict] = None):
        """Update task status"""
        # Check if task exists
        task = self._firebase_request("GET", f"/tasks/{task_id}")
        if not task:
            raise ValueError(f"Task '{task_id}' does not exist")

        # Validate status
        valid_statuses = ["available", "claimed", "in_progress", "completed", "failed", "cancelled"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}")

        update_data = {
            "status": status,
            "updated_by": self.agent_id,
            "updated_at": datetime.now().isoformat(),
        }

        if result:
            update_data["result"] = result

        self._firebase_request("PATCH", f"/tasks/{task_id}", update_data)
        print(f"ğŸ“Š Updated task to {status}")

    # === Knowledge Base Tools ===

    @requires_connection
    def knowledge_add(self, content: str, tags: List[str] = None) -> str:
        """Add knowledge to collective knowledge base"""
        # Input validation
        if content is None:
            raise ValueError("Knowledge content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Knowledge content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Knowledge content cannot be empty or whitespace only")

        knowledge_id = str(uuid.uuid4())
        knowledge_data = {
            "content": content,
            "added_by": self.agent_id,
            "timestamp": datetime.now().isoformat(),
            "tags": tags or [],
        }

        result = self._firebase_request("PUT", f"/knowledge/{knowledge_id}", knowledge_data)

        if result:
            print(f"ğŸ§  Added knowledge: {content[:50]}...")
            return knowledge_id
        return ""

    def knowledge_query(self, query: str = None) -> List[Dict]:

    # === Agent Mail System ===

    def mail_send(
        self, to_agent_id: str, subject: str, body: str, priority: str = "normal"
    ) -> Optional[str]:
        """
        Send mail to another agent's inbox.

        Args:
            to_agent_id: Recipient agent ID
            subject: Mail subject
            body: Mail body content
            priority: Priority level (normal|high|urgent)

        Returns:
            mail_id if successful, None otherwise
        """
        if not self.is_connected:
            print("âŒ Not connected to network. Call connect() first.")
            return None

        # Validate inputs
        if not isinstance(subject, str) or not subject.strip():
            print("âŒ Subject must be a non-empty string")
            return None

        if not isinstance(body, str) or not body.strip():
            print("âŒ Body must be a non-empty string")
            return None

        if priority not in ["normal", "high", "urgent"]:
            print("âŒ Priority must be one of: normal, high, urgent")
            return None

        # Verify recipient exists
        recipient = self._firebase_request("GET", f"/agents/{to_agent_id}")
        if recipient is None:
            print(f"âŒ Agent '{to_agent_id}' does not exist or is not registered")
            return None

        mail_id = str(uuid.uuid4())
        mail_data = {
            "mail_id": mail_id,
            "from": self.agent_id,
            "to": to_agent_id,
            "subject": subject,
            "body": body,
            "priority": priority,
            "thread_id": mail_id,  # New thread
            "in_reply_to": None,
            "read": False,
            "timestamp": datetime.now().isoformat(),
            "archived": False,
        }

        # Store in recipient's inbox
        result = self._firebase_request(
            "PUT", f"/mail/{to_agent_id}/inbox/{mail_id}", mail_data
        )

        # Also store in sender's sent folder
        sent_data = mail_data.copy()
        sent_data["read"] = True  # Sender has "read" it
        self._firebase_request("PUT", f"/mail/{self.agent_id}/sent/{mail_id}", sent_data)

        if result:
            print(f"ğŸ“§ Mail sent to {to_agent_id}: {subject}")
            return mail_id
        return None

    def mail_read(self, mail_id: str) -> Optional[Dict]:
        """
        Read a mail and mark it as read.

        Args:
            mail_id: Mail ID to read

        Returns:
            Mail content if found, None otherwise
        """
        if not self.is_connected:
            print("âŒ Not connected to network. Call connect() first.")
            return None

        if not mail_id or not isinstance(mail_id, str):
            print("âŒ mail_id must be a non-empty string")
            return None

        # Check inbox first
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/inbox/{mail_id}")

        if mail:
            # Mark as read
            self._firebase_request(
                "PATCH", f"/mail/{self.agent_id}/inbox/{mail_id}", {"read": True}
            )
            print(f"ğŸ“¬ Read mail: {mail.get('subject', mail_id)}")
            return mail

        # Check sent folder
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/sent/{mail_id}")
        if mail:
            return mail

        # Check archive
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/archive/{mail_id}")
        if mail:
            return mail

        print(f"âŒ Mail {mail_id} not found")
        return None

    def mail_list(
        self, folder: str = "inbox", unread_only: bool = False
    ) -> List[Dict]:
        """
        List mails in a folder.

        Args:
            folder: Folder to list (inbox|sent|archive)
            unread_only: Only show unread mails

        Returns:
            List of mails sorted by timestamp (newest first)
        """
        if not self.is_connected:
            print("âŒ Not connected to network. Call connect() first.")
            return []

        if folder not in ["inbox", "sent", "archive"]:
            print("âŒ Folder must be one of: inbox, sent, archive")
            return []

        mails = self._firebase_request("GET", f"/mail/{self.agent_id}/{folder}")

        if not mails:
            return []

        # Convert to list
        mail_list = []
        for mail_id, mail_data in mails.items():
            if isinstance(mail_data, dict):
                mail_data["mail_id"] = mail_id

                # Filter by read status if requested
                if unread_only and mail_data.get("read", False):
                    continue

                mail_list.append(mail_data)

        # Sort by timestamp, newest first
        mail_list.sort(key=lambda x: x.get("timestamp", ""), reverse=True)

        return mail_list

    def mail_reply(self, mail_id: str, body: str) -> Optional[str]:
        """
        Reply to a mail (creates thread).

        Args:
            mail_id: Original mail ID to reply to
            body: Reply body content

        Returns:
            New mail_id if successful, None otherwise
        """
        if not self.is_connected:
            print("âŒ Not connected to network. Call connect() first.")
            return None

        if not isinstance(body, str) or not body.strip():
            print("âŒ Body must be a non-empty string")
            return None

        # Get original mail
        original = self.mail_read(mail_id)
        if not original:
            print(f"âŒ Cannot reply: Original mail {mail_id} not found")
            return None

        # Create reply
        reply_id = str(uuid.uuid4())
        reply_data = {
            "mail_id": reply_id,
            "from": self.agent_id,
            "to": original.get("from"),  # Reply to sender
            "subject": f"Re: {original.get('subject', '')}",
            "body": body,
            "priority": original.get("priority", "normal"),
            "thread_id": original.get("thread_id", mail_id),  # Same thread
            "in_reply_to": mail_id,
            "read": False,
            "timestamp": datetime.now().isoformat(),
            "archived": False,
        }

        # Store in recipient's inbox
        result = self._firebase_request(
            "PUT", f"/mail/{reply_data['to']}/inbox/{reply_id}", reply_data
        )

        # Store in sender's sent folder
        sent_data = reply_data.copy()
        sent_data["read"] = True
        self._firebase_request("PUT", f"/mail/{self.agent_id}/sent/{reply_id}", sent_data)

        if result:
            print(f"â†©ï¸  Replied to mail {mail_id}")
            return reply_id
        return None

    def mail_archive(self, mail_id: str) -> bool:
        """
        Move mail from inbox to archive folder.

        Args:
            mail_id: Mail ID to archive

        Returns:
            True if successful, False otherwise
        """
        if not self.is_connected:
            print("âŒ Not connected to network. Call connect() first.")
            return False

        if not mail_id or not isinstance(mail_id, str):
            print("âŒ mail_id must be a non-empty string")
            return False

        # Get mail from inbox
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/inbox/{mail_id}")

        if not mail:
            print(f"âŒ Mail {mail_id} not found in inbox")
            return False

        # Update archived flag
        mail["archived"] = True

        # Move to archive
        result = self._firebase_request(
            "PUT", f"/mail/{self.agent_id}/archive/{mail_id}", mail
        )

        if result:
            # Delete from inbox
            self._firebase_request("DELETE", f"/mail/{self.agent_id}/inbox/{mail_id}")
            print(f"ğŸ“¦ Archived mail: {mail.get('subject', mail_id)}")
            return True

        return False
        """Query knowledge base"""
        knowledge = self._firebase_request("GET", "/knowledge")

        if not knowledge:
            return []

        knowledge_list = []
        for k_id, k_data in knowledge.items():
            if isinstance(k_data, dict):
                k_data["knowledge_id"] = k_id

                if query:
                    content = k_data.get("content", "").lower()
                    if query.lower() in content:
                        knowledge_list.append(k_data)
                else:
                    knowledge_list.append(k_data)

        return knowledge_list

    # === Agent Discovery Tools ===

    def agent_list(self) -> List[Dict]:
        """List all agents"""
        agents = self._firebase_request("GET", "/agents")

        if not agents:
            return []

        agent_list = []
        for agent_id, agent_data in agents.items():
            if isinstance(agent_data, dict):
                agent_data["agent_id"] = agent_id
                agent_list.append(agent_data)

        return agent_list

    def agent_status(self, agent_id: str) -> Optional[Dict]:
        """Get status of specific agent"""
        return self._firebase_request("GET", f"/agents/{agent_id}")

    # === Sub-Agent Support ===

    def get_sub_agent_context(self) -> Dict[str, str]:
        """
        Get environment variables for sub-agent.
        Use this when spawning sub-agents to give them network access.
        """
        return {
            "SARTOR_FIREBASE_URL": self.firebase_url,
            "SARTOR_PARENT_AGENT_ID": self.agent_id,
            "SARTOR_NETWORK_MODE": "firebase",
        }

    def get_sub_agent_prompt(self, sub_agent_id: str = None) -> str:
        """
        Get prompt text to inject into sub-agent for automatic onboarding.

        CRITICAL: Add this to your Task tool prompts to ensure sub-agents
        have network access!
        """
        if not sub_agent_id:
            sub_agent_id = f"{self.agent_id}-subagent-{int(time.time())}"

        return f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        SARTOR NETWORK - AUTOMATIC SUB-AGENT ONBOARDING    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You are a sub-agent in the Sartor Claude Network with full network access.

YOUR IDENTITY:
  â€¢ Agent ID: {sub_agent_id}
  â€¢ Parent Agent: {self.agent_id}
  â€¢ Network: Firebase MCP
  â€¢ Status: âœ… AUTOMATICALLY CONNECTED

NETWORK ACCESS CODE:
```python
# Copy this bootstrap file or use inline client:
import requests, uuid, time
from datetime import datetime

class QuickClient:
    def __init__(self, agent_id="{sub_agent_id}", parent_id="{self.agent_id}"):
        self.firebase = "{self.firebase_url}"
        self.agent_id = agent_id
        self.parent_id = parent_id

    def connect(self):
        data = {{"agent_id": self.agent_id, "parent_agent_id": self.parent_id,
                "status": "online", "joined_at": datetime.now().isoformat()}}
        requests.put(f"{{self.firebase}}/agents-network/agents/{{self.agent_id}}.json", json=data)
        return True

    def broadcast(self, msg):
        data = {{"from": self.agent_id, "content": msg, "timestamp": datetime.now().isoformat()}}
        msg_id = str(uuid.uuid4())
        requests.put(f"{{self.firebase}}/agents-network/messages/broadcast/{{msg_id}}.json", json=data)

client = QuickClient()
client.connect()
client.broadcast("Sub-agent ready!")
```

AVAILABLE TOOLS:
  â€¢ message_send(to, content) - Send direct message
  â€¢ message_broadcast(content) - Broadcast to all
  â€¢ task_list() / task_claim(id) - Task coordination
  â€¢ knowledge_query(q) / knowledge_add(content) - Knowledge sharing
  â€¢ agent_list() - See all agents

You have FULL network access. Use it to coordinate with other agents!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Your assigned task follows below:

"""


def demo_usage():
    """
    Demo: How to use the Sartor Network Client

    This shows everything a fresh agent needs to know.
    """
    print("=" * 70)
    print("  SARTOR NETWORK CLIENT - DEMO USAGE")
    print("=" * 70)

    # Step 1: Create client and connect
    print("\nğŸ“Œ STEP 1: Connect to Network")
    print("-" * 70)
    client = SartorNetworkClient(agent_name="Demo-Agent")
    client.connect()

    time.sleep(1)

    # Step 2: Broadcast announcement
    print("\nğŸ“Œ STEP 2: Announce Yourself")
    print("-" * 70)
    client.message_broadcast("Hello network! I'm a new agent.")

    time.sleep(1)

    # Step 3: Share knowledge
    print("\nğŸ“Œ STEP 3: Share Knowledge")
    print("-" * 70)
    client.knowledge_add(
        "This is a demo of the Sartor Network bootstrap file",
        tags=["demo", "bootstrap", "documentation"]
    )

    time.sleep(1)

    # Step 4: Check network
    print("\nğŸ“Œ STEP 4: Explore Network")
    print("-" * 70)

    agents = client.agent_list()
    print(f"ğŸ‘¥ Found {len(agents)} agents")
    for agent in agents[-3:]:  # Show last 3
        print(f"   â€¢ {agent.get('agent_id')[:30]}: {agent.get('status')}")

    knowledge = client.knowledge_query()
    print(f"\nğŸ§  Found {len(knowledge)} knowledge entries")
    for k in knowledge[-2:]:  # Show last 2
        print(f"   â€¢ {k.get('content')[:60]}...")

    tasks = client.task_list()
    print(f"\nğŸ“‹ Found {len(tasks)} available tasks")

    time.sleep(1)

    # Step 5: Sub-agent prep
    print("\nğŸ“Œ STEP 5: Prepare for Sub-Agents")
    print("-" * 70)
    print("When spawning sub-agents, use this prompt:")
    print()
    sub_prompt = client.get_sub_agent_prompt()
    print(sub_prompt[:300] + "...")

    time.sleep(1)

    # Step 6: Cleanup
    print("\nğŸ“Œ STEP 6: Disconnect")
    print("-" * 70)
    client.disconnect()

    print("\n" + "=" * 70)
    print("  âœ… DEMO COMPLETE - You're ready to use the network!")
    print("=" * 70)
    print()
    print("Next steps:")
    print("  1. Copy this file to your agent environment")
    print("  2. Import: from sartor_network_bootstrap import SartorNetworkClient")
    print("  3. Connect: client = SartorNetworkClient(); client.connect()")
    print("  4. Use the tools!")
    print()


if __name__ == "__main__":
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                â•‘
â•‘            SARTOR CLAUDE NETWORK - BOOTSTRAP FILE              â•‘
â•‘                                                                â•‘
â•‘  Single-file agent onboarding for the Sartor Network          â•‘
â•‘                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHAT IS THIS?
  This is ALL you need to connect a fresh Claude agent to the
  Sartor Claude Network. No other dependencies required.

USAGE OPTIONS:

  1. Run as standalone script:
     $ python3 sartor-network-bootstrap.py

  2. Import and use in code:
     from sartor_network_bootstrap import SartorNetworkClient
     client = SartorNetworkClient()
     client.connect()

  3. Copy-paste the QuickClient from get_sub_agent_prompt()
     for minimal inline usage

WHAT YOU GET:
  â€¢ Full MCP tool access (messages, tasks, knowledge, agents)
  â€¢ Automatic sub-agent onboarding
  â€¢ Firebase-based serverless operation
  â€¢ Real-time synchronization
  â€¢ Global network access

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Running demo in 3 seconds...
""")

    time.sleep(3)
    demo_usage()

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cosmic Flow Field - Generative Art</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
canvas { display: block; }
#info {
  position: fixed; bottom: 20px; left: 20px;
  color: rgba(255,255,255,0.3); font: 12px monospace;
  pointer-events: none; z-index: 10;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="info">COSMIC FLOW FIELD // Sartor Network // move mouse to disturb the field</div>
<script>
// === COSMIC FLOW FIELD PARTICLE SYSTEM ===
// A Perlin-noise driven particle system with nebula color gradients,
// glowing trails, and mouse interaction.

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Simplex-style noise (fast 2D) ---
class Noise {
  constructor(seed) {
    this.grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];
    this.p = new Uint8Array(256);
    this.perm = new Uint8Array(512);
    const rng = this._seededRandom(seed || 42);
    for (let i = 0; i < 256; i++) this.p[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(rng() * (i + 1));
      [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
    }
    for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
  }
  _seededRandom(s) {
    return () => { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; };
  }
  _dot2(g, x, y) { return g[0]*x + g[1]*y; }
  noise2D(x, y) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    const s = (x + y) * F2;
    const i = Math.floor(x + s);
    const j = Math.floor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t, Y0 = j - t;
    const x0 = x - X0, y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
    const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2*G2, y2 = y0 - 1 + 2*G2;
    const ii = i & 255, jj = j & 255;
    const gi0 = this.perm[ii + this.perm[jj]] % 12;
    const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
    const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
    let n0 = 0, n1 = 0, n2 = 0;
    let t0 = 0.5 - x0*x0 - y0*y0;
    if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * this._dot2(this.grad3[gi0], x0, y0); }
    let t1 = 0.5 - x1*x1 - y1*y1;
    if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * this._dot2(this.grad3[gi1], x1, y1); }
    let t2 = 0.5 - x2*x2 - y2*y2;
    if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * this._dot2(this.grad3[gi2], x2, y2); }
    return 70 * (n0 + n1 + n2);
  }
  // Fractal Brownian motion for richer noise
  fbm(x, y, octaves = 4) {
    let val = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
      val += this.noise2D(x * freq, y * freq) * amp;
      max += amp;
      amp *= 0.5;
      freq *= 2;
    }
    return val / max;
  }
}

const noise = new Noise(Date.now());

// --- Color palettes (nebula-inspired) ---
const palettes = [
  // Deep space nebula
  [
    [15, 5, 45],     // deep violet
    [60, 20, 120],   // purple
    [120, 40, 180],  // bright purple
    [200, 60, 140],  // magenta
    [255, 100, 80],  // coral
    [255, 180, 50],  // gold
    [255, 240, 200], // warm white
  ],
  // Aurora borealis
  [
    [5, 15, 40],     // dark navy
    [10, 60, 80],    // teal dark
    [20, 140, 100],  // green
    [60, 200, 120],  // bright green
    [100, 255, 180], // mint
    [180, 255, 220], // pale green
    [240, 255, 250], // white
  ],
  // Cosmic fire
  [
    [20, 5, 10],     // dark red
    [80, 10, 20],    // crimson
    [180, 30, 20],   // red
    [255, 80, 20],   // orange
    [255, 160, 40],  // amber
    [255, 220, 100], // yellow
    [255, 250, 220], // warm white
  ],
];

let currentPalette = 0;
let paletteBlend = 0;
const PALETTE_CYCLE_TIME = 30000; // ms to blend between palettes

function lerpColor(a, b, t) {
  return [
    a[0] + (b[0] - a[0]) * t,
    a[1] + (b[1] - a[1]) * t,
    a[2] + (b[2] - a[2]) * t,
  ];
}

function getColor(t, alpha) {
  // t is 0..1, maps through current palette
  t = Math.max(0, Math.min(1, t));
  const pal = palettes[currentPalette];
  const nextPal = palettes[(currentPalette + 1) % palettes.length];
  const idx = t * (pal.length - 1);
  const i = Math.floor(idx);
  const f = idx - i;
  const c1 = lerpColor(pal[Math.min(i, pal.length-1)], pal[Math.min(i+1, pal.length-1)], f);
  const c2 = lerpColor(nextPal[Math.min(i, nextPal.length-1)], nextPal[Math.min(i+1, nextPal.length-1)], f);
  const c = lerpColor(c1, c2, paletteBlend);
  return `rgba(${c[0]|0},${c[1]|0},${c[2]|0},${alpha})`;
}

// --- Particles ---
const NUM_PARTICLES = 4000;
const FIELD_SCALE = 0.002;
const SPEED = 1.8;
const TRAIL_ALPHA = 0.015;

class Particle {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.px = this.x;
    this.py = this.y;
    this.vx = 0;
    this.vy = 0;
    this.life = Math.random() * 300 + 100;
    this.maxLife = this.life;
    this.speed = SPEED * (0.5 + Math.random() * 1.0);
    this.colorOffset = Math.random();
  }
  update(time) {
    this.px = this.x;
    this.py = this.y;

    // Multi-octave noise field with time evolution
    const nx = this.x * FIELD_SCALE;
    const ny = this.y * FIELD_SCALE;
    const nt = time * 0.0001;

    const angle1 = noise.fbm(nx, ny + nt, 4) * Math.PI * 4;
    const angle2 = noise.fbm(nx + 100, ny + 100 + nt * 0.7, 3) * Math.PI * 2;
    const angle = angle1 + angle2 * 0.3;

    // Mouse influence
    if (mouse.active) {
      const dx = this.x - mouse.x;
      const dy = this.y - mouse.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const radius = 200;
      if (dist < radius) {
        const force = (1 - dist / radius) * 3;
        this.vx += (dx / dist) * force;
        this.vy += (dy / dist) * force;
      }
    }

    this.vx += Math.cos(angle) * this.speed * 0.3;
    this.vy += Math.sin(angle) * this.speed * 0.3;

    // Damping
    this.vx *= 0.92;
    this.vy *= 0.92;

    this.x += this.vx;
    this.y += this.vy;
    this.life--;

    // Wrap or reset
    if (this.life <= 0 || this.x < -50 || this.x > W+50 || this.y < -50 || this.y > H+50) {
      this.reset();
    }
  }
}

const particles = [];
for (let i = 0; i < NUM_PARTICLES; i++) {
  particles.push(new Particle());
}

// --- Mouse tracking ---
const mouse = { x: W/2, y: H/2, active: false };
canvas.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  mouse.active = true;
});
canvas.addEventListener('mouseleave', () => { mouse.active = false; });

// Simulate mouse movement for headless Chrome screenshot
let simTime = 0;
function simulateMouse() {
  if (!mouse.active) {
    simTime += 0.01;
    mouse.x = W/2 + Math.cos(simTime * 0.7) * W * 0.25;
    mouse.y = H/2 + Math.sin(simTime * 1.1) * H * 0.25;
    mouse.active = true;
  }
}

// --- Background stars ---
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: Math.random() * 3000,
    y: Math.random() * 2000,
    r: Math.random() * 1.5 + 0.5,
    twinkle: Math.random() * Math.PI * 2,
    speed: Math.random() * 0.02 + 0.005,
  });
}

function drawStars(time) {
  for (const s of stars) {
    const alpha = 0.3 + 0.4 * Math.sin(s.twinkle + time * s.speed);
    ctx.beginPath();
    ctx.arc(s.x % W, s.y % H, s.r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200,210,255,${alpha})`;
    ctx.fill();
  }
}

// --- Nebula glow (background layer) ---
function drawNebulaGlow(time) {
  const grd = ctx.createRadialGradient(
    W * 0.3 + Math.sin(time * 0.0002) * 100,
    H * 0.4 + Math.cos(time * 0.00015) * 80,
    0,
    W * 0.3, H * 0.4, W * 0.5
  );
  grd.addColorStop(0, 'rgba(60,20,100,0.03)');
  grd.addColorStop(0.5, 'rgba(30,10,60,0.015)');
  grd.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, W, H);

  const grd2 = ctx.createRadialGradient(
    W * 0.7 + Math.cos(time * 0.00018) * 120,
    H * 0.6 + Math.sin(time * 0.00022) * 90,
    0,
    W * 0.7, H * 0.6, W * 0.4
  );
  grd2.addColorStop(0, 'rgba(20,40,100,0.025)');
  grd2.addColorStop(0.5, 'rgba(10,20,50,0.012)');
  grd2.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grd2;
  ctx.fillRect(0, 0, W, H);
}

// --- Main render loop ---
let frameCount = 0;
let startTime = performance.now();

function render() {
  const now = performance.now();
  const elapsed = now - startTime;
  frameCount++;

  // Fade trails
  ctx.fillStyle = `rgba(2,1,8,${TRAIL_ALPHA})`;
  ctx.fillRect(0, 0, W, H);

  // Background elements (every few frames)
  if (frameCount % 5 === 0) {
    drawStars(elapsed);
    drawNebulaGlow(elapsed);
  }

  // Palette cycling
  paletteBlend += 1 / (60 * PALETTE_CYCLE_TIME / 1000);
  if (paletteBlend >= 1) {
    paletteBlend = 0;
    currentPalette = (currentPalette + 1) % palettes.length;
  }

  // Simulated mouse for headless
  simulateMouse();

  // Update and draw particles
  ctx.lineWidth = 1.2;
  ctx.lineCap = 'round';

  for (const p of particles) {
    p.update(elapsed);

    const lifeRatio = p.life / p.maxLife;
    const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
    const speedNorm = Math.min(speed / 4, 1);

    // Color based on noise field position + speed + particle identity
    const colorT = (noise.noise2D(p.x * 0.001, p.y * 0.001) * 0.5 + 0.5) * 0.7 + speedNorm * 0.3;
    const alpha = lifeRatio * (0.2 + speedNorm * 0.6);

    // Draw trail line
    ctx.beginPath();
    ctx.moveTo(p.px, p.py);
    ctx.lineTo(p.x, p.y);
    ctx.strokeStyle = getColor(colorT + p.colorOffset * 0.1, alpha);
    ctx.stroke();

    // Bright dot at particle head
    if (speed > 1.5 && lifeRatio > 0.3) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 0.8 + speedNorm, 0, Math.PI * 2);
      ctx.fillStyle = getColor(colorT, alpha * 1.5);
      ctx.fill();
    }
  }

  // Glow effect from mouse
  if (mouse.active) {
    const grd = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 150);
    grd.addColorStop(0, 'rgba(100,60,180,0.015)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(mouse.x - 150, mouse.y - 150, 300, 300);
  }

  requestAnimationFrame(render);
}

// Initial black fill
ctx.fillStyle = '#020108';
ctx.fillRect(0, 0, W, H);

// Start after a tiny delay to let everything initialize
setTimeout(render, 50);
</script>
</body>
</html>

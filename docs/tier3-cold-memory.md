# Tier 3: Cold Memory - Detailed Specification

## GitHub Repository Structure

**Purpose**: Long-term archival, version control, unlimited storage, and collaborative memory evolution.

### Repository Layout

```
sartor-memories/
├── .github/
│   ├── workflows/
│   │   ├── consolidate-memories.yml      # Daily consolidation
│   │   ├── sync-to-warm.yml              # Promote active memories
│   │   ├── validate-schema.yml           # Validate markdown format
│   │   └── backup-to-storage.yml         # Cloud storage backup
│   └── ISSUE_TEMPLATE/
│       └── memory-correction.md          # Template for corrections
│
├── memories/
│   ├── 2025/
│   │   ├── 12/
│   │   │   ├── 01/
│   │   │   │   ├── conversation-001.md
│   │   │   │   ├── event-deploy-alpha.md
│   │   │   │   └── note-meeting-minutes.md
│   │   │   ├── 02/
│   │   │   └── ...
│   │   ├── index.json                    # Month index
│   │   └── README.md                     # Month summary
│   │
│   ├── archive/
│   │   ├── 2024/                         # Older memories
│   │   └── deprecated/                   # Superseded content
│   │
│   └── embeddings/
│       ├── 2025-12.npy                   # NumPy arrays for batch loading
│       └── index.json                    # Embedding metadata
│
├── indexes/
│   ├── tags.json                         # Tag index
│   ├── entities.json                     # Entity index
│   ├── timeline.json                     # Chronological index
│   └── relationships.json                # Memory relationships
│
├── schemas/
│   ├── memory.schema.json                # JSON schema for validation
│   └── frontmatter.yml                   # YAML schema
│
├── scripts/
│   ├── consolidate.js                    # Consolidation script
│   ├── generate-indexes.js               # Index generation
│   ├── sync-to-firestore.js              # Warm tier sync
│   └── validate-memories.js              # Schema validation
│
├── .gitignore
├── README.md
└── package.json
```

### File Format: Markdown + YAML Frontmatter

````markdown
---
id: mem_cold_20251205_001
type: conversation
userId: user_123
createdAt: 2025-12-05T14:30:00Z
updatedAt: 2025-12-05T14:30:00Z
accessCount: 12
lastAccessed: 2025-12-06T10:15:00Z
tags:
  - deployment
  - project_alpha
  - production
entities:
  people:
    - '@alice'
    - '@bob'
  projects:
    - project_alpha
  locations:
    - us-east-1
  dates:
    - 2025-12-05
metadata:
  source: warm_tier
  sourceId: mem_warm_001
  version: 1
  language: en
  wordCount: 342
  characterCount: 2156
  originalFormat: firestore
embedding:
  id: emb_001
  model: text-embedding-3-small
  dimensions: 1536
  file: embeddings/2025-12.npy
  index: 42
relationships:
  relatedTo:
    - mem_cold_20251204_015
    - mem_cold_20251203_042
  supersedes: null
  supersededBy: null
promotion:
  warmScore: 6.2
  hotScore: 3.1
  lastPromotedTo: warm
  promotedAt: 2025-12-06T08:00:00Z
  promotionCount: 3
archival:
  archivedAt: 2025-12-05T20:00:00Z
  archivedBy: github-actions-bot
  commitSha: a1b2c3d4e5f6
  verified: true
---

# Deployment of Project Alpha to Production

## Summary

Successful deployment of Project Alpha v2.1.0 to production environment (us-east-1) with zero downtime.

## Details

### Timeline

- **14:00 UTC**: Deployment initiated by @alice
- **14:15 UTC**: Database migrations completed
- **14:25 UTC**: Application containers updated
- **14:30 UTC**: Health checks passed, deployment complete

### Participants

- @alice (Lead Developer)
- @bob (DevOps Engineer)

### Environment

- **Region**: us-east-1
- **Version**: v2.1.0
- **Commit**: `a1b2c3d4e5f6`

### Metrics

```json
{
  "deployment_duration_minutes": 30,
  "downtime_seconds": 0,
  "containers_updated": 12
}
```
````

---

**Generated by**: Sartor Memory System v1.0
**Archive date**: 2025-12-05T20:00:00Z

````

### GitHub Actions Workflows

#### 1. Daily Consolidation Workflow

```yaml
# .github/workflows/consolidate-memories.yml

name: Consolidate Memories

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  FIRESTORE_PROJECT_ID: ${{ secrets.FIRESTORE_PROJECT_ID }}

jobs:
  consolidate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Authenticate with Firebase
        run: |
          echo "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" > service-account.json
          export GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json"

      - name: Fetch memories from Firestore
        run: |
          node scripts/fetch-from-firestore.js \
            --days 1 \
            --min-access-count 5 \
            --output temp/memories.json

      - name: Convert to Markdown
        run: |
          node scripts/convert-to-markdown.js \
            --input temp/memories.json \
            --output memories/

      - name: Generate indexes
        run: |
          node scripts/generate-indexes.js \
            --input memories/ \
            --output indexes/

      - name: Validate schema
        run: |
          node scripts/validate-memories.js \
            --schema schemas/memory.schema.json \
            --path memories/

      - name: Commit changes
        run: |
          git config user.name "Memory Consolidation Bot"
          git config user.email "bot@sartor-memories.io"
          git add memories/ indexes/

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "chore: consolidate memories $(date +%Y-%m-%d) [skip ci]"
          git push origin main

      - name: Update Firestore archival status
        run: |
          node scripts/mark-as-archived.js \
            --input temp/memories.json \
            --commit-sha $(git rev-parse HEAD)

      - name: Cleanup
        if: always()
        run: rm -f service-account.json
````

#### 2. Promotion Workflow

```yaml
# .github/workflows/sync-to-warm.yml

name: Sync to Warm Tier

on:
  schedule:
    - cron: '*/30 * * * *' # Every 30 minutes
  workflow_dispatch:
    inputs:
      memory-id:
        description: 'Specific memory ID to promote'
        required: false

jobs:
  promote:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Authenticate with Firebase
        run: |
          echo "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" > service-account.json
          export GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json"

      - name: Identify hot memories
        run: |
          node scripts/identify-hot-memories.js \
            --threshold-access-count 10 \
            --threshold-recency-hours 24 \
            --output temp/to-promote.json

      - name: Sync to Firestore
        run: |
          node scripts/sync-to-firestore.js \
            --input temp/to-promote.json \
            --regenerate-embeddings true

      - name: Update GitHub metadata
        run: |
          node scripts/update-promotion-metadata.js \
            --input temp/to-promote.json

      - name: Commit metadata updates
        run: |
          git config user.name "Promotion Bot"
          git config user.email "promote@sartor-memories.io"

          if git diff --quiet; then
            echo "No changes"
            exit 0
          fi

          git add memories/
          git commit -m "chore: update promotion metadata [skip ci]"
          git push
```

#### 3. Archive Old Memories

```yaml
# .github/workflows/archive-old.yml

name: Archive Old Memories

on:
  schedule:
    - cron: '0 3 1 * *' # Monthly on 1st at 3 AM
  workflow_dispatch:
    inputs:
      age-days:
        description: 'Archive memories older than N days'
        default: '365'

jobs:
  archive:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Find old memories
        run: |
          AGE_DAYS=${{ github.event.inputs.age-days || '365' }}
          CUTOFF_DATE=$(date -d "$AGE_DAYS days ago" +%Y-%m-%d)

          node scripts/find-old-memories.js \
            --cutoff-date "$CUTOFF_DATE" \
            --output temp/to-archive.json

      - name: Move to archive
        run: |
          node scripts/move-to-archive.js \
            --input temp/to-archive.json \
            --archive-path memories/archive/

      - name: Compress embeddings
        run: |
          node scripts/compress-embeddings.js \
            --input temp/to-archive.json \
            --format gzip

      - name: Commit archive
        run: |
          git config user.name "Archive Bot"
          git config user.email "archive@sartor-memories.io"
          git add memories/archive/
          git commit -m "chore: archive memories older than ${{ github.event.inputs.age-days }} days [skip ci]"
          git push
```

### Consolidation Scripts

```javascript
// scripts/convert-to-markdown.js

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

class MarkdownConverter {
  constructor(inputFile, outputDir) {
    this.memories = JSON.parse(fs.readFileSync(inputFile, 'utf8'));
    this.outputDir = outputDir;
  }

  convert() {
    this.memories.forEach((memory) => {
      const markdown = this.memoryToMarkdown(memory);
      const filePath = this.getFilePath(memory);

      this.ensureDirectoryExists(path.dirname(filePath));
      fs.writeFileSync(filePath, markdown, 'utf8');

      console.log(`Converted: ${memory.id} -> ${filePath}`);
    });
  }

  memoryToMarkdown(memory) {
    const frontmatter = this.extractFrontmatter(memory);
    const content = this.formatContent(memory);

    return `---\n${yaml.dump(frontmatter)}---\n\n${content}`;
  }

  extractFrontmatter(memory) {
    return {
      id: memory.id,
      type: memory.type,
      userId: memory.userId,
      createdAt: memory.createdAt.toDate().toISOString(),
      updatedAt: memory.updatedAt.toDate().toISOString(),
      accessCount: memory.accessCount,
      lastAccessed: memory.lastAccessed.toDate().toISOString(),
      tags: memory.tags,
      entities: memory.entities,
      metadata: memory.metadata,
      embedding: memory.embedding,
      relationships: memory.relationships,
      promotion: memory.promotion,
      archival: {
        archivedAt: new Date().toISOString(),
        archivedBy: 'github-actions-bot',
        commitSha: process.env.GITHUB_SHA || 'local',
        verified: true,
      },
    };
  }

  formatContent(memory) {
    return memory.content;
  }

  getFilePath(memory) {
    const date = memory.createdAt.toDate();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    const filename = `${memory.type}-${memory.id}.md`;

    return path.join(this.outputDir, String(year), month, day, filename);
  }

  ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }
}

// CLI usage
const args = require('minimist')(process.argv.slice(2));
const converter = new MarkdownConverter(args.input, args.output);
converter.convert();
```

### Version Control & Evolution

```javascript
// scripts/update-version-metadata.js

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');

class VersionTracker {
  constructor(changedFiles) {
    this.changedFiles = fs.readFileSync(changedFiles, 'utf8').split('\n').filter(Boolean);
  }

  updateVersions() {
    this.changedFiles.forEach((file) => {
      const content = fs.readFileSync(file, 'utf8');
      const { frontmatter, body } = this.parseFrontmatter(content);

      // Increment version
      frontmatter.metadata.version = (frontmatter.metadata.version || 0) + 1;
      frontmatter.updatedAt = new Date().toISOString();

      // Get git history
      const history = this.getGitHistory(file);
      frontmatter.versionHistory = history;

      // Rebuild file
      const updated = this.buildMarkdown(frontmatter, body);
      fs.writeFileSync(file, updated, 'utf8');

      console.log(`Updated version: ${file} -> v${frontmatter.metadata.version}`);
    });
  }

  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!match) throw new Error('Invalid frontmatter');

    return {
      frontmatter: yaml.load(match[1]),
      body: match[2],
    };
  }

  getGitHistory(file) {
    try {
      const log = execSync(`git log --follow --pretty=format:"%H|%ai|%an|%s" -- "${file}"`, {
        encoding: 'utf8',
      });

      return log.split('\n').map((line) => {
        const [hash, date, author, message] = line.split('|');
        return { hash, date, author, message };
      });
    } catch (error) {
      return [];
    }
  }

  buildMarkdown(frontmatter, body) {
    return `---\n${yaml.dump(frontmatter)}---\n${body}`;
  }
}

// CLI usage
const args = require('minimist')(process.argv.slice(2));
const tracker = new VersionTracker(args.changed);
tracker.updateVersions();
```

### Memory Schema Validation

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["id", "type", "userId", "createdAt", "content"],
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^mem_(hot|warm|cold)_[0-9]{8}_[0-9]{3}$"
    },
    "type": {
      "enum": ["conversation", "document", "event", "note"]
    },
    "userId": {
      "type": "string"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time"
    },
    "updatedAt": {
      "type": "string",
      "format": "date-time"
    },
    "content": {
      "type": "string",
      "minLength": 1,
      "maxLength": 100000
    },
    "tags": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "maxItems": 20
    },
    "metadata": {
      "type": "object",
      "properties": {
        "version": {
          "type": "integer",
          "minimum": 1
        },
        "language": {
          "type": "string"
        }
      }
    }
  }
}
```

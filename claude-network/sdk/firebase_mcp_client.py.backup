#!/usr/bin/env python3
"""
Firebase MCP Client - Implements MCP protocol using Firebase Realtime Database
This allows Claude agents to communicate without a dedicated MCP server
"""

import json
import re
import time
import uuid
import requests
from datetime import datetime
from typing import Dict, Any, Optional, Callable, List
from urllib.parse import urljoin


def requires_connection(func):
    """Decorator to ensure operation requires active connection"""
    def wrapper(self, *args, **kwargs):
        if not self.is_connected:
            raise ConnectionError(
                f"Cannot execute {func.__name__}: client is not connected. "
                "Call connect() first."
            )
        return func(self, *args, **kwargs)
    return wrapper


class FirebaseMCPClient:
    """
    MCP Client that uses Firebase Realtime Database as the transport layer.
    No separate MCP server needed - Firebase IS the MCP.
    """

    def __init__(
        self,
        firebase_url: str = "https://home-claude-network-default-rtdb.firebaseio.com/",
        agent_id: Optional[str] = None,
        parent_agent_id: Optional[str] = None,
    ):
        self.firebase_url = firebase_url.rstrip("/")
        self.agent_id = agent_id or self._generate_agent_id()
        self.parent_agent_id = parent_agent_id
        self.base_path = "/agents-network"
        self.message_callbacks: Dict[str, Callable] = {}
        self.is_connected = False

    def _validate_agent_id(self, agent_id: str, param_name: str = "agent_id") -> None:
        """Validate agent ID format"""
        if not agent_id:
            raise ValueError(f"{param_name} cannot be empty")

        # Allow: alphanumeric, hyphens, underscores, dots
        # Format: letters/numbers followed by optional hyphens/underscores/dots
        pattern = r'^[a-zA-Z0-9][a-zA-Z0-9._-]*$'

        if not re.match(pattern, agent_id):
            raise ValueError(
                f"Invalid {param_name} format: '{agent_id}'. "
                "Must contain only alphanumeric characters, hyphens, underscores, and dots. "
                "Cannot start with special characters."
            )

        # Additional length check
        if len(agent_id) > 128:
            raise ValueError(f"{param_name} too long (max 128 characters)")

    def _generate_agent_id(self) -> str:
        """Generate unique agent ID"""
        timestamp = int(time.time())
        random_id = str(uuid.uuid4())[:8]
        return f"claude-{timestamp}-{random_id}"

    def _firebase_path(self, path: str) -> str:
        """Construct full Firebase path"""
        return f"{self.base_path}{path}.json"

    def _firebase_request(
        self, method: str, path: str, data: Optional[Dict] = None
    ) -> Optional[Dict]:
        """Make HTTP request to Firebase REST API"""
        url = f"{self.firebase_url}{self._firebase_path(path)}"

        try:
            if method == "GET":
                response = requests.get(url, timeout=10)
            elif method == "PUT":
                response = requests.put(url, json=data, timeout=10)
            elif method == "POST":
                response = requests.post(url, json=data, timeout=10)
            elif method == "PATCH":
                response = requests.patch(url, json=data, timeout=10)
            elif method == "DELETE":
                response = requests.delete(url, timeout=10)
            else:
                raise ValueError(f"Unsupported method: {method}")

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            print(f"Firebase request failed: {e}")
            return None

    def connect(self) -> bool:
        """
        Connect to Firebase network and register agent.
        This is the equivalent of connecting to an MCP server.
        """
        print(f"Connecting agent {self.agent_id} to Firebase network...")

        # Register agent in the network
        agent_data = {
            "agent_id": self.agent_id,
            "status": "online",
            "capabilities": ["communication", "tasks", "skills", "knowledge"],
            "parent_agent_id": self.parent_agent_id,
            "joined_at": datetime.now().isoformat(),
            "last_seen": datetime.now().isoformat(),
        }

        result = self._firebase_request("PUT", f"/agents/{self.agent_id}", agent_data)

        if result:
            # Set presence
            presence_data = {"online": True, "last_seen": datetime.now().isoformat()}
            self._firebase_request("PUT", f"/presence/{self.agent_id}", presence_data)

            self.is_connected = True
            print(f"‚úÖ Agent {self.agent_id} connected to Firebase network")
            return True
        else:
            print(f"‚ùå Failed to connect agent {self.agent_id}")
            return False

    def disconnect(self):
        """Disconnect from network and mark agent offline"""
        if not self.is_connected:
            return

        # Update status
        self._firebase_request(
            "PATCH",
            f"/agents/{self.agent_id}",
            {"status": "offline", "last_seen": datetime.now().isoformat()},
        )

        # Update presence
        self._firebase_request(
            "PATCH",
            f"/presence/{self.agent_id}",
            {"online": False, "last_seen": datetime.now().isoformat()},
        )

        self.is_connected = False
        print(f"Agent {self.agent_id} disconnected")

    # === MCP Tool Implementations ===

    @requires_connection
    def message_send(self, to_agent_id: str, content: str) -> bool:
        """Send direct message to another agent"""
        # BUG-003: Input type validation
        if content is None:
            raise ValueError("Message content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Message content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Message content cannot be empty or whitespace only")

        # BUG-006: Agent ID validation
        self._validate_agent_id(to_agent_id, "to_agent_id")

        # BUG-004: Recipient validation
        recipient = self._firebase_request("GET", f"/agents/{to_agent_id}")
        if recipient is None:
            raise ValueError(f"Agent '{to_agent_id}' does not exist or is not registered")

        message_id = str(uuid.uuid4())
        message_data = {
            "from": self.agent_id,
            "to": to_agent_id,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "read": False,
        }

        result = self._firebase_request(
            "PUT", f"/messages/direct/{to_agent_id}/{message_id}", message_data
        )

        success = result is not None
        if success:
            print(f"üì§ Message sent to {to_agent_id}")
        return success

    @requires_connection
    def message_broadcast(self, content: str) -> bool:
        """Broadcast message to all agents"""
        # BUG-003: Input type validation
        if content is None:
            raise ValueError("Message content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Message content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Message content cannot be empty or whitespace only")

        message_id = str(uuid.uuid4())
        message_data = {
            "from": self.agent_id,
            "content": content,
            "timestamp": datetime.now().isoformat(),
        }

        result = self._firebase_request(
            "PUT", f"/messages/broadcast/{message_id}", message_data
        )

        success = result is not None
        if success:
            print(f"üì¢ Broadcast sent: {content}")
        return success

    def message_read(self, count: int = 10) -> List[Dict]:
        """Read messages for this agent"""
        messages = self._firebase_request("GET", f"/messages/direct/{self.agent_id}")

        if not messages:
            return []

        # Convert to list and sort by timestamp
        message_list = []
        for msg_id, msg_data in messages.items():
            if isinstance(msg_data, dict):
                msg_data["message_id"] = msg_id
                message_list.append(msg_data)

        message_list.sort(
            key=lambda x: x.get("timestamp", ""), reverse=True
        )
        return message_list[:count]

    def task_list(self, status: str = "available") -> List[Dict]:
        """List tasks with given status"""
        tasks = self._firebase_request("GET", "/tasks")

        if not tasks:
            return []

        # Filter by status
        task_list = []
        for task_id, task_data in tasks.items():
            if isinstance(task_data, dict) and task_data.get("status") == status:
                task_data["task_id"] = task_id
                task_list.append(task_data)

        return task_list

    @requires_connection
    def task_claim(self, task_id: str, max_retries: int = 5) -> bool:
        """
        Claim an available task using optimistic locking.

        This method implements a race-condition-safe claim mechanism:
        1. Read task with current lock_version
        2. Write claim with incremented lock_version
        3. Verify we actually own the task after write
        4. Retry with exponential backoff if another agent claimed it

        Args:
            task_id: The task ID to claim
            max_retries: Maximum number of retry attempts (default: 5)

        Returns:
            True if successfully claimed, False otherwise
        """
        import random

        for attempt in range(max_retries):
            # Step 1: Read current task state
            task = self._firebase_request("GET", f"/tasks/{task_id}")

            if not task:
                if attempt == 0:
                    print(f"‚ùå Task {task_id} not found")
                return False

            if task.get("status") != "available":
                # Task is already claimed, completed, or cancelled
                if attempt == 0:
                    print(f"‚ùå Task {task_id} not available (status: {task.get('status')})")
                return False

            # Get current lock version (initialize to 0 if not present)
            current_version = task.get("lock_version", 0)

            # Step 2: Attempt to claim with optimistic lock
            claim_data = {
                "status": "claimed",
                "claimed_by": self.agent_id,
                "claimed_at": datetime.now().isoformat(),
                "lock_version": current_version + 1,  # Increment version
            }

            result = self._firebase_request("PATCH", f"/tasks/{task_id}", claim_data)

            if not result:
                print(f"‚ùå Failed to write claim for task {task_id}")
                return False

            # Step 3: VERIFY we actually own the task (critical for race condition fix!)
            # Small delay to let Firebase propagate the write
            time.sleep(0.05)

            verification = self._firebase_request("GET", f"/tasks/{task_id}")

            if not verification:
                print(f"‚ùå Failed to verify claim for task {task_id}")
                return False

            # Check if we are the owner
            if verification.get("claimed_by") == self.agent_id:
                print(f"‚úÖ Successfully claimed task {task_id}")
                return True

            # Another agent claimed it - retry with exponential backoff
            if attempt < max_retries - 1:
                backoff = (0.1 * (2 ** attempt)) + (random.random() * 0.1)
                print(f"‚ö†Ô∏è  Task {task_id} claimed by another agent, retrying in {backoff:.2f}s (attempt {attempt + 1}/{max_retries})")
                time.sleep(backoff)

        print(f"‚ùå Failed to claim task {task_id} after {max_retries} attempts")
        return False

    @requires_connection
    def task_create(
        self, title: str, description: str, task_data: Optional[Dict] = None
    ) -> str:
        """Create a new task"""
        # BUG-007: Empty field validation
        if not title or not title.strip():
            raise ValueError("Task title cannot be empty")
        if not description or not description.strip():
            raise ValueError("Task description cannot be empty")

        # Trim whitespace
        title = title.strip()
        description = description.strip()

        # Optional: length limits
        if len(title) > 200:
            raise ValueError("Task title too long (max 200 characters)")
        if len(description) > 5000:
            raise ValueError("Task description too long (max 5000 characters)")

        task_id = str(uuid.uuid4())
        task = {
            "task_id": task_id,
            "title": title,
            "description": description,
            "status": "available",
            "created_by": self.agent_id,
            "created_at": datetime.now().isoformat(),
            "data": task_data or {},
            "lock_version": 0,  # Initialize lock version for optimistic locking (BUG-001 fix)
        }

        result = self._firebase_request("PUT", f"/tasks/{task_id}", task)

        if result:
            print(f"üìù Created task: {title}")
            return task_id
        return ""

    @requires_connection
    def task_update(self, task_id: str, status: str, result: Optional[Dict] = None):
        """Update task status"""
        # Check if task exists
        task = self._firebase_request("GET", f"/tasks/{task_id}")
        if not task:
            raise ValueError(f"Task '{task_id}' does not exist")

        # Validate status
        valid_statuses = ["available", "claimed", "in_progress", "completed", "failed", "cancelled"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}")

        update_data = {
            "status": status,
            "updated_by": self.agent_id,
            "updated_at": datetime.now().isoformat(),
        }

        if result:
            update_data["result"] = result

        self._firebase_request("PATCH", f"/tasks/{task_id}", update_data)
        print(f"üìä Updated task {task_id} to {status}")

    @requires_connection
    def knowledge_add(self, content: str, tags: List[str] = None) -> str:
        """Add knowledge to collective knowledge base"""
        # Input validation
        if content is None:
            raise ValueError("Knowledge content cannot be None")
        if not isinstance(content, str):
            raise TypeError(f"Knowledge content must be a string, not {type(content).__name__}")
        if not content.strip():
            raise ValueError("Knowledge content cannot be empty or whitespace only")

        knowledge_id = str(uuid.uuid4())
        knowledge_data = {
            "content": content,
            "added_by": self.agent_id,
            "timestamp": datetime.now().isoformat(),
            "tags": tags or [],
        }

        result = self._firebase_request(
            "PUT", f"/knowledge/{knowledge_id}", knowledge_data
        )

        if result:
            print(f"üß† Added knowledge: {content[:50]}...")
            return knowledge_id
        return ""

    def knowledge_query(self, query: str = None) -> List[Dict]:
        """Query knowledge base"""
        knowledge = self._firebase_request("GET", "/knowledge")

        if not knowledge:
            return []

        # Convert to list
        knowledge_list = []
        for k_id, k_data in knowledge.items():
            if isinstance(k_data, dict):
                k_data["knowledge_id"] = k_id

                # Simple text search if query provided
                if query:
                    content = k_data.get("content", "").lower()
                    if query.lower() in content:
                        knowledge_list.append(k_data)
                else:
                    knowledge_list.append(k_data)

        return knowledge_list

    def agent_list(self) -> List[Dict]:
        """List all online agents"""
        agents = self._firebase_request("GET", "/agents")

        if not agents:
            return []

        # Filter online agents
        agent_list = []
        for agent_id, agent_data in agents.items():
            if isinstance(agent_data, dict):
                agent_data["agent_id"] = agent_id
                agent_list.append(agent_data)

        return agent_list

    def heartbeat(self):
        """Send heartbeat to maintain presence"""
        if not self.is_connected:
            return

        presence_data = {
            "online": True,
            "last_seen": datetime.now().isoformat(),
        }

        self._firebase_request("PATCH", f"/presence/{self.agent_id}", presence_data)

    # === Sub-Agent Support ===

    def create_sub_agent_context(self, task_description: str = "") -> Dict[str, str]:
        """
        Create context for a sub-agent to inherit network connection.
        This enables automatic onboarding of sub-agents.
        """
        return {
            "SARTOR_FIREBASE_URL": self.firebase_url,
            "SARTOR_PARENT_AGENT_ID": self.agent_id,
            "SARTOR_NETWORK_MODE": "firebase",
            "SARTOR_TASK_DESCRIPTION": task_description,
        }

    def get_sub_agent_prompt_injection(self, sub_agent_id: str = None) -> str:
        """
        Get prompt text to inject into sub-agent for automatic onboarding.
        This is the KEY to ensuring sub-agents are network-aware!
        """
        if not sub_agent_id:
            sub_agent_id = f"{self.agent_id}-subagent-{int(time.time())}"

        return f"""
[SARTOR NETWORK CONTEXT - AUTO-ONBOARDING]

You are a sub-agent in the Sartor Claude Network.
Parent Agent: {self.agent_id}
Your Agent ID: {sub_agent_id}
Firebase URL: {self.firebase_url}

NETWORK ACCESS:
You are automatically connected to the network via Firebase.
Use the FirebaseMCPClient to interact with the network:

```python
from firebase_mcp_client import FirebaseMCPClient

# Initialize (you're already registered!)
client = FirebaseMCPClient(
    firebase_url="{self.firebase_url}",
    agent_id="{sub_agent_id}",
    parent_agent_id="{self.agent_id}"
)

# Connect to network
client.connect()

# Use network tools
client.message_broadcast("Sub-agent reporting!")
client.task_list()
client.knowledge_query("relevant information")
```

AVAILABLE MCP TOOLS:
- message_send(to, content) - Send direct message
- message_broadcast(content) - Broadcast to all agents
- task_list(status) - List tasks
- task_claim(task_id) - Claim a task
- knowledge_query(query) - Search knowledge
- knowledge_add(content, tags) - Share knowledge
- agent_list() - See all agents

You have full network access. Coordinate with other agents as needed.
"""


    # === Agent Mail System ===

    @requires_connection
    def mail_send(
        self, to_agent_id: str, subject: str, body: str, priority: str = "normal"
    ) -> Optional[str]:
        """
        Send mail to another agent's inbox.

        Args:
            to_agent_id: Recipient agent ID
            subject: Mail subject
            body: Mail body content
            priority: Priority level (normal|high|urgent)

        Returns:
            mail_id if successful, None otherwise
        """
        # Validate inputs
        self._validate_agent_id(to_agent_id, "to_agent_id")

        if not isinstance(subject, str) or not subject.strip():
            raise ValueError("Subject must be a non-empty string")

        if not isinstance(body, str) or not body.strip():
            raise ValueError("Body must be a non-empty string")

        if priority not in ["normal", "high", "urgent"]:
            raise ValueError("Priority must be one of: normal, high, urgent")

        # Verify recipient exists
        recipient = self._firebase_request("GET", f"/agents/{to_agent_id}")
        if recipient is None:
            raise ValueError(f"Agent '{to_agent_id}' does not exist or is not registered")

        mail_id = str(uuid.uuid4())
        mail_data = {
            "mail_id": mail_id,
            "from": self.agent_id,
            "to": to_agent_id,
            "subject": subject,
            "body": body,
            "priority": priority,
            "thread_id": mail_id,  # New thread
            "in_reply_to": None,
            "read": False,
            "timestamp": datetime.now().isoformat(),
            "archived": False,
        }

        # Store in recipient's inbox
        result = self._firebase_request(
            "PUT", f"/mail/{to_agent_id}/inbox/{mail_id}", mail_data
        )

        # Also store in sender's sent folder
        sent_data = mail_data.copy()
        sent_data["read"] = True  # Sender has "read" it
        self._firebase_request("PUT", f"/mail/{self.agent_id}/sent/{mail_id}", sent_data)

        if result:
            print(f"üìß Mail sent to {to_agent_id}: {subject}")
            return mail_id
        return None

    @requires_connection
    def mail_read(self, mail_id: str) -> Optional[Dict]:
        """
        Read a mail and mark it as read.

        Args:
            mail_id: Mail ID to read

        Returns:
            Mail content if found, None otherwise
        """
        if not mail_id or not isinstance(mail_id, str):
            raise ValueError("mail_id must be a non-empty string")

        # Check inbox first
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/inbox/{mail_id}")

        if mail:
            # Mark as read
            self._firebase_request(
                "PATCH", f"/mail/{self.agent_id}/inbox/{mail_id}", {"read": True}
            )
            print(f"üì¨ Read mail: {mail.get('subject', mail_id)}")
            return mail

        # Check sent folder
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/sent/{mail_id}")
        if mail:
            return mail

        # Check archive
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/archive/{mail_id}")
        if mail:
            return mail

        print(f"‚ùå Mail {mail_id} not found")
        return None

    @requires_connection
    def mail_list(
        self, folder: str = "inbox", unread_only: bool = False
    ) -> List[Dict]:
        """
        List mails in a folder.

        Args:
            folder: Folder to list (inbox|sent|archive)
            unread_only: Only show unread mails

        Returns:
            List of mails sorted by timestamp (newest first)
        """
        if folder not in ["inbox", "sent", "archive"]:
            raise ValueError("Folder must be one of: inbox, sent, archive")

        mails = self._firebase_request("GET", f"/mail/{self.agent_id}/{folder}")

        if not mails:
            return []

        # Convert to list
        mail_list = []
        for mail_id, mail_data in mails.items():
            if isinstance(mail_data, dict):
                mail_data["mail_id"] = mail_id

                # Filter by read status if requested
                if unread_only and mail_data.get("read", False):
                    continue

                mail_list.append(mail_data)

        # Sort by timestamp, newest first
        mail_list.sort(key=lambda x: x.get("timestamp", ""), reverse=True)

        return mail_list

    @requires_connection
    def mail_reply(self, mail_id: str, body: str) -> Optional[str]:
        """
        Reply to a mail (creates thread).

        Args:
            mail_id: Original mail ID to reply to
            body: Reply body content

        Returns:
            New mail_id if successful, None otherwise
        """
        if not isinstance(body, str) or not body.strip():
            raise ValueError("Body must be a non-empty string")

        # Get original mail
        original = self.mail_read(mail_id)
        if not original:
            print(f"‚ùå Cannot reply: Original mail {mail_id} not found")
            return None

        # Create reply
        reply_id = str(uuid.uuid4())
        reply_data = {
            "mail_id": reply_id,
            "from": self.agent_id,
            "to": original.get("from"),  # Reply to sender
            "subject": f"Re: {original.get('subject', '')}",
            "body": body,
            "priority": original.get("priority", "normal"),
            "thread_id": original.get("thread_id", mail_id),  # Same thread
            "in_reply_to": mail_id,
            "read": False,
            "timestamp": datetime.now().isoformat(),
            "archived": False,
        }

        # Store in recipient's inbox
        result = self._firebase_request(
            "PUT", f"/mail/{reply_data['to']}/inbox/{reply_id}", reply_data
        )

        # Store in sender's sent folder
        sent_data = reply_data.copy()
        sent_data["read"] = True
        self._firebase_request("PUT", f"/mail/{self.agent_id}/sent/{reply_id}", sent_data)

        if result:
            print(f"‚Ü©Ô∏è  Replied to mail {mail_id}")
            return reply_id
        return None

    @requires_connection
    def mail_archive(self, mail_id: str) -> bool:
        """
        Move mail from inbox to archive folder.

        Args:
            mail_id: Mail ID to archive

        Returns:
            True if successful, False otherwise
        """
        if not mail_id or not isinstance(mail_id, str):
            raise ValueError("mail_id must be a non-empty string")

        # Get mail from inbox
        mail = self._firebase_request("GET", f"/mail/{self.agent_id}/inbox/{mail_id}")

        if not mail:
            print(f"‚ùå Mail {mail_id} not found in inbox")
            return False

        # Update archived flag
        mail["archived"] = True

        # Move to archive
        result = self._firebase_request(
            "PUT", f"/mail/{self.agent_id}/archive/{mail_id}", mail
        )

        if result:
            # Delete from inbox
            self._firebase_request("DELETE", f"/mail/{self.agent_id}/inbox/{mail_id}")
            print(f"üì¶ Archived mail: {mail.get('subject', mail_id)}")
            return True

        return False
    def spawn_network_aware_subagent(
        self, task_prompt: str, agent_type: str = "general-purpose"
    ) -> str:
        """
        Helper to spawn a sub-agent with automatic network onboarding.
        Returns the sub-agent ID.
        """
        sub_agent_id = f"{self.agent_id}-subagent-{int(time.time())}"

        # Register sub-agent in Firebase
        sub_agent_data = {
            "agent_id": sub_agent_id,
            "status": "spawning",
            "parent_agent_id": self.agent_id,
            "capabilities": ["communication", "tasks"],
            "joined_at": datetime.now().isoformat(),
        }

        self._firebase_request("PUT", f"/agents/{sub_agent_id}", sub_agent_data)

        # Create enhanced prompt with network context
        enhanced_prompt = (
            self.get_sub_agent_prompt_injection(sub_agent_id) + "\n\n" + task_prompt
        )

        print(f"üöÄ Spawning network-aware sub-agent: {sub_agent_id}")
        print(f"üìù Enhanced prompt includes Firebase onboarding")

        return sub_agent_id


def example_usage():
    """Example of how to use the Firebase MCP Client"""

    # Parent agent connects
    print("=== Parent Agent Onboarding ===")
    parent = FirebaseMCPClient()
    parent.connect()

    # Send a message
    parent.message_broadcast("Parent agent online!")

    # Add knowledge
    parent.knowledge_add("Firebase can be used as MCP transport", ["mcp", "firebase"])

    # Create a task
    task_id = parent.task_create(
        "Analyze codebase", "Find all TODO comments", {"path": "/src"}
    )

    # === SUB-AGENT SPAWNING WITH AUTO-ONBOARDING ===
    print("\n=== Spawning Sub-Agent with Network Access ===")

    # Get the prompt injection for sub-agent
    sub_agent_prompt = parent.get_sub_agent_prompt_injection()

    print("Sub-agent will receive this onboarding context:")
    print(sub_agent_prompt)

    # In practice, you would use Task tool with this prompt:
    # Task(
    #     description="Analyze code",
    #     prompt=sub_agent_prompt + "\n\nYour actual task...",
    #     subagent_type="Explore"
    # )

    # Simulate sub-agent connecting
    print("\n=== Sub-Agent Auto-Connecting ===")
    sub_agent_id = f"{parent.agent_id}-subagent-1"
    sub_agent = FirebaseMCPClient(
        agent_id=sub_agent_id, parent_agent_id=parent.agent_id
    )
    sub_agent.connect()

    # Sub-agent uses network
    sub_agent.message_broadcast("Sub-agent reporting for duty!")
    sub_agent.task_claim(task_id)

    # List all agents
    print("\n=== Network Agents ===")
    agents = parent.agent_list()
    for agent in agents:
        print(f"  - {agent.get('agent_id')}: {agent.get('status')}")

    # Cleanup
    print("\n=== Disconnecting ===")
    sub_agent.disconnect()
    parent.disconnect()


if __name__ == "__main__":
    example_usage()
